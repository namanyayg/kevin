<html>
  <head>
    <link rel="stylesheet" href="node_modules/@xterm/xterm/css/xterm.css" />
    <script src="node_modules/@xterm/xterm/lib/xterm.js"></script>
    <script src="node_modules/@xterm/addon-attach/lib/addon-attach.js"></script>
    <style>
      #terminal {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
    </style>
  </head>
<body>
  <div id="terminal"></div>

  <script>
    // in the "terminal", render a terminal with websockets
    const terminal = document.getElementById("terminal");
    const form = document.getElementById("chat");
    const input = document.getElementById("input");
    var term;

    // Load xterm and xterm-attach
    const socket = new WebSocket("ws://localhost:6060");
    socket.onopen = () => {
      const attachAddon = new AttachAddon.AttachAddon(socket);
      term = new Terminal();
      term.loadAddon(attachAddon);
      term.open(document.getElementById("terminal"));
      term.focus();
    }

    let isPtyReady = true
    let latestData = ''
    let terminalPromptData = ''
    socket.onmessage = (message) => {
      latestData = message.data
      if (!terminalPromptData) {
        setTimeout(() => {
          terminalPromptData = message.data
          console.log('terminal prompt chosen', terminalPromptData)
          isPtyReady = true
          console.log('PTY is ready')
        }, 500)
      }
      console.log('received message from pty', message.data)

      // if latest data is equal to the terminal prompt message,
      // then we can say that it is "ready"
      isPtyReady = latestData === terminalPromptData
      console.log(isPtyReady ? 'PTY is ready' : 'PTY is not ready')
    }

    const executeLikeNaturalTyping = (string) => {
      return new Promise((resolve) => {
        let i = 0;
        const interval = setInterval(() => {
          socket.send(string[i]);
          i++;
          if (i === string.length) {
            clearInterval(interval);
            resolve();
          }
        }, 50);
      });
    }

    const messages = [];

    const chat = (message) => {
      messages.push({
        role: "user",
        content: message
      }); // Append the new message to the messages array
      console.log(message)
      // Send the entire messages array to the OpenAI API
      // Replace 'YOUR_OPENAI_API_ENDPOINT' with the actual endpoint URL
      return fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer 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' // Add the authorization bearer token here
        },
        body: JSON.stringify({
          model: 'gpt-4-turbo-preview',
          messages
        }),
      })
        .then((response) => response.json())
        .then((data) => {
          if (data.error) throw new Error(data.error.message);
          console.log(data)
          // Update the messages array with the response from OpenAI
          const choices = data.choices;
          const lastChoice = choices[choices.length - 1];
          const responseMessage = lastChoice.message;
          messages.push({
            role: "assistant",
            content: responseMessage.content
          });
          console.log(messages)
          return responseMessage.content
        })
        .catch((error) => {
          console.error(error);
        });
    };

    const planAndExecuteGoal = async (goal) => {
      const message = `
You are inside a shell.
Provide a series of terminal commands one after the other to ${goal}

Use only valid node js code and jest for testing.
Also write a test for the same.

All the text you give will directly be sent to a terminal, so don't include any unnecessary text and always give full response for any code. ONLY reply in valid terminal commands. Do NOT use echo or sed, only use "nano" to edit files.

EVERYTHING YOU SAY WILL DIRECTLY BE SENT TO A TERMINAL, so only reply with a stream of keypresses that will get the result. Please only provide a stream of keypresses to be piped into an actual terminal without any explanation or text. You can provide control characters like ^X to close nano. Instead of "Enter", use \\n. Please only send valid commands and keypresses that can execute the goal in a terminal directly, do not write any explanation or comments or I might lose my job.`
      const responseMessage = await chat(message)

      // remove ```bash and ``` from the message
      let responseMessageCleaned = responseMessage
        .replace(/```bash/g, '')
        .replace(/```/g, '')

      // convert all escape sequences to ascii characters. For example, ^O is represented by \x0f (ASCII 15) and ^X is represented by \x18 (ASCII 24).
      responseMessageCleaned = responseMessageCleaned
        .replace(/\^O/g, '\x0f')
        .replace(/\^X/g, '\x18')

      // replace \\n to \n
      responseMessageCleaned = responseMessageCleaned.replace(/\\n/g, '\n')

      // Send the response to the socket, line by line, using executeLikeNaturalTyping
      const lines = responseMessageCleaned.split('\n');
      console.log(lines)
      executeLinesWhenReady(lines)
    }

    const executeLinesWhenReady = async (lines) => {
      for (const line of lines) {
        // don't execute if line = sh
        if (["shell", "sh", ""].includes(line)) {
          continue;
        }
        while (!isPtyReady) {
          console.log('waiting for pty to be ready')
          await new Promise((resolve) => setTimeout(resolve, 1000));
        }
        console.log('pty is ready, running next line after small wait')
        await new Promise((resolve) => setTimeout(resolve, 500));
        await executeLikeNaturalTyping(line + '\r');
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
    }
  </script>
</body>
</html>